#!/usr/bin/env python3
"""
Phreakwall Firewall Compiler

The firewall compiler reads configuration files and generates
optimized firewall scripts for execution.

Copyright (c) 2025 Phreakwall Contributors
Based on Shorewall Compiler (c) 2007-2019 Tom Eastep

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License version 2.
"""

import argparse
import logging
import sys
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from phreakwall.core.chains import ChainManager

from phreakwall.core.config import Config
from phreakwall.modules.nat import NatManager
from phreakwall.modules.rules import RuleProcessor
from phreakwall.modules.zones import ZoneManager


@dataclass
class CompilerOptions:
    """Compiler configuration options."""

    script: Optional[Path] = None
    directory: Path = Path("/etc/phreakwall")
    verbosity: int = 0
    timestamp: bool = False
    debug: bool = False
    export: bool = False
    log_file: Optional[Path] = None
    log_verbosity: int = 0
    test: bool = False
    preview: bool = False
    family: int = 4  # 4 for IPv4, 6 for IPv6
    confess: bool = False
    update: bool = False
    annotate: bool = False
    config_path: Optional[str] = None
    output: Optional[Path] = None


class CompilerError(Exception):
    """Base exception for compiler errors."""

    pass


class Compiler:
    """
    Main firewall compiler class.

    Orchestrates the compilation of firewall configuration files
    into executable firewall scripts.
    """

    VERSION = "6.0.0"

    def __init__(self, options: CompilerOptions):
        """
        Initialize the compiler.

        Args:
            options: Compiler configuration options
        """
        self.options = options
        self.config: Config
        self.chain_manager: ChainManager
        self.zone_manager: ZoneManager
        self.nat_manager: NatManager
        self.rule_processor: RuleProcessor
        self.output_lines: List[str] = []

        # Setup logging
        self._setup_logging()
        self.logger = logging.getLogger(__name__)

    def _setup_logging(self):
        """Configure logging based on options."""
        level_map = {
            -1: logging.ERROR,
            0: logging.WARNING,
            1: logging.INFO,
            2: logging.DEBUG,
        }

        level = level_map.get(self.options.verbosity, logging.INFO)

        log_format = "%(levelname)s: %(message)s"
        if self.options.timestamp:
            log_format = "%(asctime)s " + log_format

        handlers: list = [logging.StreamHandler(sys.stdout)]

        if self.options.log_file:
            handlers.append(logging.FileHandler(str(self.options.log_file)))

        logging.basicConfig(level=level, format=log_format, handlers=handlers)

    def initialize_components(self):
        """Initialize all compiler components."""
        self.logger.info("Initializing Phreakwall compiler v%s", self.VERSION)

        # Load configuration
        self.config = Config(
            config_dir=self.options.directory,
            family=self.options.family,
            export=self.options.export,
        )
        self.config.load()

        # Initialize managers
        self.chain_manager = ChainManager(
            family=self.options.family, export=self.options.export
        )

        self.zone_manager = ZoneManager(config=self.config, family=self.options.family)

        self.nat_manager = NatManager(config=self.config, family=self.options.family)

        self.rule_processor = RuleProcessor(
            config=self.config,
            chain_manager=self.chain_manager,
            zone_manager=self.zone_manager,
            family=self.options.family,
        )

    def generate_script_header(self) -> List[str]:
        """
        Generate the script header.

        Returns:
            List of header lines
        """
        lines = ["#!/bin/bash", "#", "# Phreakwall Firewall Script", "#"]

        if not self.options.test:
            date_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            lines.extend(
                [
                    f"# Generated by Phreakwall {self.VERSION}",
                    f"# Date: {date_str}",
                    "#",
                ]
            )
        else:
            lines.append("# Generated by Phreakwall")

        lines.extend(["", "set -e", "", "# Phreakwall runtime library", ""])

        return lines

    def generate_script_body(self) -> List[str]:
        """
        Generate the main script body.

        Returns:
            List of script body lines
        """
        lines = []

        # Add runtime functions
        lines.extend(self._generate_runtime_functions())

        # Generate chains
        lines.extend(self.chain_manager.generate_chains())

        # Process zones
        lines.extend(self.zone_manager.generate_zone_rules())

        # Process NAT rules
        lines.extend(self.nat_manager.generate_nat_rules())

        # Process firewall rules
        lines.extend(self.rule_processor.generate_rules())

        return lines

    def _generate_runtime_functions(self) -> List[str]:
        """Generate runtime helper functions."""
        return [
            "# Runtime helper functions",
            "",
            "error_exit() {",
            '    echo "ERROR: $1" >&2',
            "    exit 1",
            "}",
            "",
            "run_iptables() {",
            "    if [ $VERBOSITY -ge 2 ]; then",
            '        echo "Running: iptables $@"',
            "    fi",
            '    iptables "$@" || error_exit "iptables command failed: $@"',
            "}",
            "",
        ]

    def generate_script_footer(self) -> List[str]:
        """
        Generate the script footer.

        Returns:
            List of footer lines
        """
        return [
            "",
            "# End of generated script",
            "exit 0",
        ]

    def compile(self) -> int:
        """
        Run the compilation process.

        Returns:
            Exit code (0 for success, non-zero for error)
        """
        try:
            self.logger.info("Starting compilation")

            # Initialize all components
            self.initialize_components()

            # Check mode - validate only, don't generate script
            if not self.options.script:
                self.logger.info("Running in check mode")
                self.validate_configuration()
                self.logger.info("Configuration is valid")
                return 0

            # Generate the firewall script
            self.logger.info("Generating firewall script: %s", self.options.script)

            self.output_lines = []
            self.output_lines.extend(self.generate_script_header())
            self.output_lines.extend(self.generate_script_body())
            self.output_lines.extend(self.generate_script_footer())

            # Write output
            self._write_output()

            # Preview if requested
            if self.options.preview:
                self._preview_output()

            self.logger.info("Compilation completed successfully")
            return 0

        except CompilerError as e:
            self.logger.error("Compilation failed: %s", e)
            if self.options.debug or self.options.confess:
                raise
            return 1

        except Exception as e:
            self.logger.error("Unexpected error: %s", e)
            if self.options.debug or self.options.confess:
                raise
            return 1

    def validate_configuration(self):
        """Validate the configuration without generating output."""
        self.logger.debug("Validating configuration")

        # Validate zones
        self.zone_manager.validate()

        # Validate NAT rules
        self.nat_manager.validate()

        # Validate firewall rules
        self.rule_processor.validate()

        self.logger.debug("Validation completed")

    def _write_output(self):
        """Write the generated script to file."""
        output_path = self.options.script or self.options.output

        if not output_path:
            # Write to stdout
            for line in self.output_lines:
                print(line)
        else:
            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)

            with output_path.open("w") as f:
                f.write("\n".join(self.output_lines))
                f.write("\n")

            # Make executable
            output_path.chmod(0o755)

            self.logger.info("Script written to: %s", output_path)

    def _preview_output(self):
        """Display a preview of the generated output."""
        print("\n" + "=" * 70)
        print("PREVIEW OF GENERATED SCRIPT")
        print("=" * 70 + "\n")

        for i, line in enumerate(self.output_lines[:50], 1):
            print(f"{i:4d}: {line}")

        if len(self.output_lines) > 50:
            print(f"\n... ({len(self.output_lines) - 50} more lines)")

        print("\n" + "=" * 70 + "\n")


def main():
    """Main entry point for the compiler."""
    parser = argparse.ArgumentParser(
        description="Phreakwall Firewall Compiler v" + Compiler.VERSION,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "script", nargs="?", type=Path, help="Output script file (omit for check mode)"
    )

    parser.add_argument(
        "-e", "--export", action="store_true", help="Compile for export"
    )

    parser.add_argument(
        "-d",
        "--directory",
        type=Path,
        default=Path("/etc/phreakwall"),
        help="Configuration directory (default: /etc/phreakwall)",
    )

    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        dest="verbosity",
        help="Increase verbosity (-v, -vv)",
    )

    parser.add_argument(
        "-t", "--timestamp", action="store_true", help="Add timestamps to log messages"
    )

    parser.add_argument("--debug", action="store_true", help="Enable debug mode")

    parser.add_argument("-l", "--log", type=Path, dest="log_file", help="Log file path")

    parser.add_argument(
        "--test", action="store_true", help="Test mode (omit version/timestamps)"
    )

    parser.add_argument(
        "--preview", action="store_true", help="Preview the generated ruleset"
    )

    parser.add_argument(
        "-f",
        "--family",
        type=int,
        choices=[4, 6],
        default=4,
        help="IP family (4 for IPv4, 6 for IPv6)",
    )

    parser.add_argument(
        "--version", action="version", version=f"Phreakwall Compiler {Compiler.VERSION}"
    )

    args = parser.parse_args()

    # Create compiler options
    options = CompilerOptions(
        script=args.script,
        directory=args.directory,
        verbosity=args.verbosity,
        timestamp=args.timestamp,
        debug=args.debug,
        export=args.export,
        log_file=args.log_file,
        test=args.test,
        preview=args.preview,
        family=args.family,
    )

    # Create and run compiler
    compiler = Compiler(options)
    return compiler.compile()


if __name__ == "__main__":
    sys.exit(main())
